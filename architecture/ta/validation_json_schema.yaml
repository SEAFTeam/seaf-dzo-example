
functions:
  validate_json_schema_v0_1:
    title: Функция валидации по JSON схеме сущности
    params:
      - alias: json_schema
        type: object
        title: Схема JSON
        required: true
      - alias: objects
        type: object
        title: Объекты для валидации
        required: true
    code: >
      (
          $validator := $jsonschema(json_schema);
          $errors := $validator(objects);
      
          [$map($errors, function($v){( $v ~> | $.params | {}, ["allowedValues"]| )}) ];
      )

  validate_json_schema_v1:
    title: Функция валидации по JSON схеме сущности
    params:
      - alias: json_schema
        type: object
        title: Схема JSON
        required: true
      - alias: objects
        type: object
        title: Объекты для валидации
        required: true
    result:
      type: array
      items:
        type: object
        properties:
          uid:
            type: string
            title: Уникальный идентификатор ошибки
          id:
            type: string
            title: Идентификатор объекта
          attr_id:
            type: string
            title: Идентификатор атрибута
          attr_name:
            type: string
            title: Название атрибута
          link:
            type: string
            title: Ссылка на объект
          sub:
            type: string
            title: Подтип ошибки
          keyword:
            type: string
            title: Ключевое слово ошибки
          error_text:
            type: string
            title: Текст ошибки (на русском)
          message:
            type: string
            title: Сообщение об ошибке (на английском)
        required: [uid, id, link, keyword, message]
    # TODO: attr_id может быть пустым, если не проходит валидация объект целиком (например, это не объекта, а массив)
    code: >
      (
          $validator := $jsonschema(json_schema);
          $errors := $validator(objects);
          /* Формат возвращаемых объектов в функции $validator */
          /* 
              1. В схеме отсутствует обязательный параметр (required):
                  - keyword принимает значение required
                  - instancePath содержит путь в сущности до отсутствующего поля (не включая само поле)
                  - schemaPath содержит путь в схеме до отсутствующего свойства и заканчивается на required (это часть схемы)
                  - params содержит ключ missingProperty с наименованием отсутствующего поля
              2.1 Ошибка в атрибуте схемы вне допустимых значений enum. Тип поля не массив
                  - keyword принимает значение enum
                  - instancePath содержит путь в сущности до неверного поля
                  - schemaPath содержит путь в схеме до атрибута с ограничением enum и заканчивается на enum
                  - params содержит ключ allowedValues со списком допустимых значений
              2.2 Ошибка в атрибуте схемы вне допустимых значений. Поле описано с использованием $refs
                  - keyword принимает значение enum
                  - instancePath содержит путь в сущности до неверного поля
                  - schemaPath содержит значение соответствуюшего $refs
                  - params содержит ключ allowedValues со списком допустимых значений
                  !NOTE! среди возвращаемых параметров отсутствует пусть в схеме
              2.3 Ошибка в атрибуте схемы вне допустимых значений enum. Тип поля массив (содержит items)
                  - keyword принимает значение enum
                  - instancePath содержит путь в сущности до неверного поля и заканчивается индексом объекта в массиве
                  - schemaPath содержит путь в схеме до элемента массива (включая свойство items) и заканчивается на enum
                  - params содержит ключ allowedValues со списком допустимых значений
              2.4 Ошибка в атрибуте схемы вне допустимых значений. Поле описано с использованием $refs и является массивом (содержит items в описании схемы)
                  - keyword принимает значение enum
                  - instancePath содержит путь в сущности до неверного поля и заканчивается индексом неверного объекта в массиве
                  - schemaPath содержит значение соответствуюшего $refs
                  - params содержит ключ allowedValues со списком допустимых значений
          */
      
          $squash_array := function($v) {( $count($v) > 1 ? $v.* : $v )};
      
          /* Не поддерживаем разбор ошибок схемы oneOf/anyOf/allOf */
          $multi_errors := $errors[$.keyword in ['anyOf', 'oneOf', 'allOf']].instancePath;
      
          /* Обрабатываем ошибки схемы по тем атрибутам, в которых не используется oneOf/anyOf/allOf */
          $base_errors := [ [ [$filter($errors, function($v) {$not($v.instancePath in $multi_errors)}) ]
              /* Если в схеме есть поля-ссылки $refs, которые описаны без использования oneOf/anyOf/allOf, будем обрабатывать их отдельно */
              ~> $filter(?, function($v){ $not($v.keyword = 'enum' and $v.schemaPath ~> /\$rels/) }) ]
      
              ~> $map(?, function($v) {(
                  $ids := $split( $v.instancePath, "/" );
                  $entity := $ids[1];
                  $object_id := $ids[2];
      
                  $propsPath := $split($v.schemaPath, "/").$decodeUrlComponent();
      
                  /* Отдельно обрабатываем ошибки в элементах массива */
                  $is_array := $v.keyword = 'enum' and $propsPath[-2] = 'items' ? true : false;
            
                  $attr_id := $v.keyword = 'required' ? $count($ids) - 1 > 2 ? $join( $ids[[3..$count($ids)-1]], ":") & ":" & $v.params.missingProperty : $v.params.missingProperty 
                              : $v.keyword = 'type' or $v.keyword = 'minItems' or $v.keyword = 'pattern'? $join( $ids[[3..$count($ids)-1]], ":")
                              : $v.keyword = 'enum' and $is_array ? $join( $ids[[3..$count($ids)-2]], ":")
                              : $v.keyword = 'enum' and $not($is_array) ? $join( $ids[[3..$count($ids)-1]], ":");
      
                  $attr_name := $v.keyword = 'required'? ($reduce($propsPath[[1..$count($propsPath)-2]], function($object, $value){$lookup($object, $value)}, json_schema).properties ~> $lookup(?, $v.params.missingProperty)).title
                                  : (
                                      $is_array ? $reduce($propsPath[[1..$count($propsPath)-3]], function($object, $value){$lookup($object, $value)}, json_schema).title
                                        : $reduce($propsPath[[1..$count($propsPath)-2]], function($object, $value){$lookup($object, $value)}, json_schema).title
                                    );
      
                  $value := $v.keyword = 'enum' or $v.keyword = 'pattern' ? ( 
                                                                              $lookup(objects, $entity) ~> $lookup(?, $object_id) 
                                                                                  ~> $reduce($split($attr_id, ":"), function($object, $value){$lookup($object, $value)}, ?);
                                                                            );
                  $value := $v.keyword = 'enum' and $is_array ? $value[$number($ids[-1])] : $value;
      
                  $prefix := $entity & "-" & $object_id & "-" & $attr_id & "-";
                  $prefix := $exists($value) ? ($not($is_array) ? $prefix & $value & "-" : $prefix & $ids[-1] & "-")
                                          : $prefix;
          
                  $error_text := $v.keyword = 'required' ? 'Атрибут ' & $attr_id & ' не может быть пустым'
                                  : $v.keyword = 'pattern' ? 'Значение "' & $value & '" не соответствуте паттерну ' & $v.params.pattern
                                  : $v.keyword = 'enum' ? 'Значение "' & $value &'" не из словаря допустимых значений'
                                  : $v.keyword = 'minItems' ? 'Не может содержать менее ' & $v.params.limit & ' элемента(-ов)'
                                  : $v.keyword = 'type' ? 'Значение не соответствует типу атрибута (должно иметь тип ' & $v.params.type & ')';
                  $error_text := $is_array ? $error_text & ". Индекс элемента: " & $ids[-1] : $error_text;
      
                  {
                      "uid": $prefix & $v.keyword,
                      "id": $object_id,
                      "title": ($lookup(objects, $entity) ~> $lookup(?, $object_id)).title, 
                      "entity": $entity,
                      "attr_id": $attr_id,
                      "attr_name": $attr_name,
                      "debug": $v ~> | $.params | {}, ["allowedValues"]|,
                      "value": $value,
                      "link": "/entities/" & $entity & "/card?id=" & $object_id,
                      "keyword": $v.keyword,
                      'error_text': $error_text ? $error_text : $v.message,
                      "message": $v.message
                  }
              )})];
      
              /* Обрабатываем ошибки схемы по тем атрибутам, в которых не используется oneOf/anyOf/allOf */
              /* Отдельно обрабатываем поля-ссылки $refs, которые описаны без использования oneOf/anyOf/allOf */
              $rels_errors := [ [ [$filter($errors, function($v) {$not($v.instancePath in $multi_errors)}) ]
                  ~> $filter(?, function($v){ $v.keyword = 'enum' and $v.schemaPath ~> /\$rels/ }) ]
                  ~> $map(?, function($v) {(
                      $ids := $split( $v.instancePath, "/" );
                      $entity := $ids[1];
                      $object_id := $ids[2];
      
                      $propsPath := $split($v.schemaPath, "/").$decodeUrlComponent();

                      /* Отдельно обрабатываем ошибки в элементах массива */
                      /* Для rels теряется информация о схеме, используем косвенный признак для определения массива */
                      $is_array := $ids[-1] ~> /^(\d)+$/ ? true : false;
      
                      $attr_id := $is_array ? $join( $ids[[3..$count($ids)-2]], ":") : $join( $ids[[3..$count($ids)-1]], ":");
                      /* TODO attr_id может быть составным, нужно поддержать рекурсивный поиск в схеме */
                      $attr_name := ($lookup(json_schema.properties, $entity).patternProperties.*.properties ~> $lookup(?, $attr_id)).title;
      
                      $value := $lookup(objects, $entity) 
                                  ~> $lookup(?, $object_id) 
                                      ~> $reduce($split($attr_id, ":"), function($object, $value){$lookup($object, $value)}, ?);
                      $value := $is_array ? $value[$number($ids[-1])] : $value;
      
                      $prefix := $entity & "-" & $object_id & "-" & $attr_id & "-";
                      $prefix := $not($is_array) ? $prefix & $value & "-" : $prefix & $ids[-1] & "-";
      
                      $error_text := 'Значение "' & $value &'" не найдено среди идентификаторов';
                      $error_text := $is_array ? $error_text & ". Индекс элемента: " & $ids[-1] : $error_text;
      
                      {
                          "uid": $prefix & $v.keyword,
                          "id": $object_id,
                          "title": ($lookup(objects, $entity) ~> $lookup(?, $object_id)).title, 
                          "entity": $entity,
                          "attr_id": $attr_id,
                          "attr_name": $attr_name,
                          "debug": $v ~> | $.params | {}, ["allowedValues"]|,
                          "value": $value,
                          "link": "/entities/" & $entity & "/card?id=" & $object_id,
                          "keyword": $v.keyword,
                          'error_text': $error_text ? $error_text : $v.message,
                          "message": $v.message
                      }
              )})];
      
              /* Оставляем ошибки, которые относятся к oneOf, anyOf, allOf */
              /* И группируем их по instancePath - элементу, к которому они относятся */
              $some_of_enum_errors := [ [ [ [ [$filter($errors, function($v) {$v.instancePath in $multi_errors}) { $.instancePath : [$ ~> | $.params | {}, "allowedValues"|] }
                /* Оставляем только те, в которых больше 1 элемента с типом allOf, anyOf, allOf;
                  возможно по-другому схему составить нельзя, фильтрация сделана чтобы избежжать неожидаемого поведения */
                ~> $sift(?, function($v, $k) {
                              $v[$.keyword in ['anyOf', 'oneOf', 'allOf']] ~> $count() = 1
                   })
                    /*  Составляем общую информацию об ошибке, добавляем подтип и подошибки */
                    ~> $each(?, function($v, $k) {(
                                  $merge([ $filter([$v], function($obj) { $obj.keyword in ['anyOf', 'oneOf', 'allOf'] }),
                                    {
                                    "subkeyword": [$filter([$v], function($obj) {$not( $obj.keyword in ['anyOf', 'oneOf', 'allOf'] )} ) ~> $lookup(?, "keyword") ~> $distinct() ],
                                    "suberrors":  $filter([$v], function($obj) { $not( $obj.keyword in ['anyOf', 'oneOf', 'allOf'] )} )
                                    }
                                  ])
                       )})]
                      /* Не обрабатываем ошибки относящиеся к required описанию вариантов схемы */
                      ~> $filter(?, function($v) { $not( 'required' in $v.subkeyword )})]
                      ~> $each(?, function($v) {(
                                [
                                    $map($v.subkeyword, function($subkeyword) {(
                                        $merge([ $v,
                                            {"suberrors": $filter($v.suberrors, function($obj){ $obj.keyword = $subkeyword} )},
                                            {"subkeyword": $subkeyword}
                                        ])
                                    )})
                                ]
                            )})].$map($, $append(?)) ]
                      ~>  $map(?, function($v){(
                              $ids := $split( $v.instancePath, "/" );
                              $entity := $ids[1];
                              $object_id := $ids[2];
      
                              $propsPath := $split($v.schemaPath, "/").$decodeUrlComponent();

                              /* Отдельно обрабатываем ошибки в элементах массива */
                              $is_array := $v.subkeyword = 'enum' and $propsPath[-2] = 'items' ? true : false;
      
                              $attr_id :=  $v.subkeyword = 'type' or $v.subkeyword = 'minItems' or $v.subkeyword = 'pattern'? $join( $ids[[3..$count($ids)-1]], ":")
                                          : $v.subkeyword = 'enum' and $is_array ? $join( $ids[[3..$count($ids)-2]], ":")
                                          : $v.subkeyword = 'enum' and $not($is_array) ? $join( $ids[[3..$count($ids)-1]], ":");
      
                              $attr_name := $is_array ? $reduce($propsPath[[1..$count($propsPath)-3]], function($object, $value){$lookup($object, $value)}, json_schema).title
                                              : $reduce($propsPath[[1..$count($propsPath)-2]], function($object, $value){$lookup($object, $value)}, json_schema).title;
                              
                              $value := $v.subkeyword = 'enum' ? ( 
                                                                $lookup(objects, $entity) ~> $lookup(?, $object_id) 
                                                                    ~> $reduce($split($attr_id, ":"), function($object, $value){$lookup($object, $value)}, ?);
                                                              );
                              $value := $type($value) != 'object' and  $v.subkeyword = 'enum' and $is_array ? [$value][$number($ids[-1])] : $value;
      
                              $prefix := $entity & "-" & $object_id & "-" & $attr_id & "-";
                              $prefix := $exists($value) ? ($not($is_array) ? $prefix & $value & "-" : $prefix & $ids[-1] & "-")
                                                      : $prefix;
      
                              $error_text := $v.subkeyword = 'pattern' ? 'Значение "' & $value & '" не соответствуте паттерну ' & $join($v.suberrors.params.pattern ~> $distinct(), ',')
                                              : $v.subkeyword = 'enum' ? 'Значение "' & $value &'" не из словаря допустимых значений'
                                              : $v.subkeyword = 'minItems' ? 'Не может содержать менее ' & $join($v.suberrors.params.limit ~> $distinct(), ',') & ' элемента(-ов)'
                                              : $v.subkeyword = 'type' ? 'Значение не соответствует типу атрибута (должно иметь тип ' & $join($v.suberrors.params.type ~> $distinct(), ',') & ')';
                              $error_text := $is_array ? $error_text & ". Индекс элемента: " & $ids[-1] : $error_text;
                              {
                                  "uid": $prefix & $v.keyword & "-" & $v.subkeyword,
                                  "id": $object_id,
                                  "title": ($lookup(objects, $entity) ~> $lookup(?, $object_id)).title, 
                                  "entity": $entity,
                                  "attr_id": $attr_id,
                                  "attr_name": $attr_name,
                                  "debug": $v ~> | $.params | {}, ["allowedValues"]|,
                                  "value": $value,
                                  "link": "/entities/" & $entity & "/card?id=" & $object_id,
                                  "keyword": $v.keyword,
                                  'error_text': $error_text ? $error_text : $v.message,
                                  "message": $v.message
                              }
                            )}) ];
      
              [$base_errors, $rels_errors, $some_of_enum_errors];
      )